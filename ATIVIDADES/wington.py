# -*- coding: utf-8 -*-
"""Wington

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1brl-6sjgDpIkanUZrKzVQk7xJZQLdvmi
"""

# Basic functions
import numpy as np
import matplotlib.pyplot as plt

# Import tensorflow and some keras functions
import tensorflow as tf
import tensorflow.keras as kr
from tensorflow.keras.layers import Dense
from tensorflow.keras.models import Model

from sklearn.model_selection import train_test_split

# Biblioteca para visualização.
from mlxtend.plotting import plot_decision_regions

"""Problema Sintético: OU-Exclusivo com Ruído Gaussiano"""

# Parâmetros
Npts = 250  # x4
Centers = np.array([[0,0],[1,1],[1,0],[0,1]])
spread = 0.2

# Gerar os dados;
X = np.vstack([spread*np.random.randn(Npts,2)+c for c in Centers])
y = np.hstack([np.zeros(2*Npts,dtype=int),np.ones(2*Npts,dtype=int)])

Xtr, Xte, ytr, yte = train_test_split(X, y, test_size=0.33, random_state=42)

plt.figure(figsize=(12,6))
plt.subplot(1,2,1)
plt.scatter(Xtr[:,0],Xtr[:,1],c=ytr)
plt.grid(True)
plt.title("Train")

plt.subplot(1,2,2)
plt.scatter(Xte[:,0],Xte[:,1],c=yte)
plt.grid(True)
plt.title("Test")

"""Modelo Linear Real"""

input = kr.Input(shape=(X.shape[1],))
output = Dense(1,activation='sigmoid')(input)
nn_real = Model(inputs=input, outputs=output, name="real_neuron")

nn_real.compile(optimizer='sgd',
              loss='BinaryCrossentropy',
              metrics=['accuracy'])

nn_real.fit(Xtr, ytr, epochs=100, validation_data=(Xte,yte), verbose=True)

plt.figure(figsize=(8,6))
plot_decision_regions(Xte,yte,nn_real)

"""Soft Universal Binary Neuron"""

def tf_sigmoid_complex(x_real,x_imag,K,epsilon=0.1):
  K2 = int(K/2)
  DeltaTheta = np.pi/K2
  angs = K2-0.5+tf.math.atan2(x_imag,x_real)/DeltaTheta
  return tf.math.reduce_sum([((-1)**k)*tf.math.sigmoid((angs-k)/epsilon) for k in range(K)],axis=0)

# Wrap the custom activation function in a Keras Layer
class ComplexSigmoid(kr.layers.Layer):
    def __init__(self, K=4, epsilon=0.1, **kwargs):
        super().__init__(**kwargs)
        self.K = K
        self.epsilon = epsilon

    def call(self, inputs):
        x_real, x_imag = inputs
        return tf_sigmoid_complex(x_real, x_imag, self.K, self.epsilon)

"""A ativação do neurônio e:
$$ z = w_1 x_1 + w_2 x_2 - \theta. $$
Escrevendo $w_i = u_i + v_i i$ e $\theta = a+bi$, temos
$$ z = (u_1 + v_1 i)x_1 + (u_2 + v_2 i)x_2 - (a+b i),$$
ou ainda
$$ z = (u_1 x_1 + u_2 x_2 - a) + (u_2 x_1 + v_2 x_2 - b) i.$$
Portanto,
$$ real(z) = u_1 x_1 + u_2x_2 - a,$$
e
$$ imag(z) = v_1 x_1 + v_2x_2 - b,$$
que podem ser interpretadas como neurônios reais (sem função de ativação).
"""

input = kr.Input(shape=(X.shape[1],))
z_real = Dense(1,activation=None)(input)
z_imag = Dense(1,activation=None)(input)
output = ComplexSigmoid(K=4)([z_real, z_imag]) # Use the custom layer
nn_complex = Model(inputs=input, outputs=output, name="complex_neuron")

nn_complex.compile(optimizer='sgd',
              loss='BinaryCrossentropy',
              metrics=['accuracy'])

nn_complex.fit(Xtr, ytr, epochs=100, validation_data=(Xte,yte), verbose=True)

plt.figure(figsize=(8,6))
plot_decision_regions(Xte,yte,nn_complex)

